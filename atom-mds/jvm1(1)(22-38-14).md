# 类的生命周期:
- **加载->(验证->准备->解析)(连接)->初始化->使用->卸载**
- 类被加载到虚拟机内存开始，到卸载出内存为止，生命周期包含： **加载，验证，准备，解析，初始化，使用，卸载** 7个阶段，加载，验证，准备，初始化和卸载这5个顺序是确定的，解析阶段则不一定，他在某些情况下可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定。

## 类加载机制:
- 加载:通过类的全限定名,将类加载如方法区,在内存中生成一个java.lang.Class对象,
作为方法区这个类的各种数据访问入口.
- 验证:确保Class文件的字节流包含的信息符合当前虚拟机的要求.
- 准备:正式为类变量分配内存,并设置变量初始值.这些变量都存储在方法区.
- 解析:将常量池中的符号引用替换为直接引用的过程,虚拟机不会重新再解析而是通过缓存去拿出解析的数据
- 初始化:在准备阶段已经赋过一个系统要求的初始值,而在初始化阶段则通过程序制定的主管计划去初始化变量和其他资源,从另一个角度理解就是 **执行类构造器的<clinit>()方法** .<clinit>()方法是由编译器自动收集类中的所有变量的复制动作和静态语句中的语句合并产生的. **静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的，在静态语句块中只能赋值不能访问**

## 类加载器:
- 比较两个类是否相等,只有在这两个类是由同一个类加载器加载的前提下才有意义.否则必定不相等.
### 双亲委派模型:
![](http://upload-images.jianshu.io/upload_images/3311132-17e1362e03164870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/434)
```
从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，
是虚拟机的一部分，另一种是所有其他的类加载器，这些加载器由java语言实现，
独立虚拟机之外，都继承抽象类java.lang.ClassLoader
```
- 启动类加载器: Boostrap ClassLoader
- 拓展类加载器: Extension ClassLoader
- 应用程序类加载器:Application ClassLoader

- 类加载器之间父子关系一般不会以继承的关系来实现，都是使用组合关系来复用父加载器的代码，如果一个类加载器收到类加载请求，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成，每一个层次都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器，只有当父类反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。他的一个好处是Java类随着他的类加载器一起具备了一种带有优先级的层次关系，例如java.lang.Object，他存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类

# 内存分配:
- 程序计数器: 线程私有,通过程序计数器获取下一条要执行的指令
- 虚拟机栈:  线程私有,每个方法调用到执行完成的过程,都对应入栈到出栈的过程. 包括:
> 方法出口,局部变量表:在局部变量表中存放着基本数据类型和引用

- 堆:线程共享,主要存的是new出来的对象,作为垃圾回收主要照顾的地方
- 本地方法栈: 与虚拟机栈类似,只是存的方法是native方法
- 方法区: 存的是类的信息,常量,静态变量

# 怎么使用ajax请求获取 freemarker局部模板内容,写入当前页面

# JVM GC
## 堆的结构:
> 堆被划分为新生代和旧生代,新生代又被进一步划分为Eden和Survivor区,Survivor由 FromSpace与ToSpace组成

![](http://img.blog.csdn.net/20141107222921959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhiMTIzR0dHR0dH/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- YoungGen{Eden,Survivor{FromSpace,ToSpace}},OldGen ratio diagram

![](http://img.blog.csdn.net/20141107224401036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhiMTIzR0dHR0dH/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
> JVM用永久代（PermanetGeneration）
来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代
的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。

## GC
- Minor GC:发生在新生代中的垃圾收集动作,采用的是复制算法
> 复制算法: 当对象在Eden,From出生后,在经过一次Minor GC后如果对象还存活,并且能够被另外一款Survivor区域(to)所容纳,则将这些对象复制到另外一款Survivor区域中,然后清理Eden,From区域.以后对象每熬过一次Minor GC,就将对象的年龄加1,当对象年龄达到15岁后,这些对象就会成为老年代.例外:对于一些较大的对象,则是直接进入老年代.

- Full GC:发生在老年代的垃圾收集动作,所采用的是 标记-整理算法,标记-整理算法
> 标记-清除算法: GC线程与程序中的线程配合,除了GC线程的其他线程都处于阻塞状态(stop the world),然后进行标记:遍历所有的GC Roots,然后将所有GC Roots可达的对象标记为存活的对象. 清除:将没有标记的对象全部清除. 缺点:大量碎片,如果存入较大的对象,需要的寻址开销增大.

> 标记-整理算法:在标记-清除的算法基础上,再加上内存整理,即清除完将存活对象推向内存一端.

- GC Root:
1. 虚拟机栈中的引用对象.
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的对象

- 内存分配与回收策略:
1. 对象优先存在Eden区,内存不够时,发生一次Minor GC.
2. 大对象直接进入老年代,因为相对而言YoungGen是OldGen的二分之一
3. 长期存活的对象将进入老年代,默认是15岁
4. 动态年龄判定,对象不一定要15岁才能进入老年区,进入survivor区的对象相同年龄的大小总和超过该内存一半,则该年龄取代15岁
5. 空间分配担保:年轻代发送YGC时,会把存活的对象存入到空的survivor中,存不下的话放入老年区.老年区也可能存不下,所以会判断老年代中最大的连续可用内存是否大于历次晋升到老年代的对象的平均大小.存的下就进行担保,否则进行一次full GC后存入.

- 除了堆中的对象需要被回收,方法区中废弃的常量与类也需要被回收
- 那么类的回收需要满足什么条件:
> 三个条件需要全部满足（周志明书上有）：1.该类的实例已经都被回收，即Java中不再有该类的任何实例。2.加载该类的ClassLoader已经被回收。3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

- [] permGen 与方法区
